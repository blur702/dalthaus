{
  "version": 3,
  "sources": ["../../tinymce/plugins/searchreplace/plugin.js", "../../tinymce/plugins/searchreplace/index.js"],
  "sourcesContent": ["/**\n * TinyMCE version 7.9.1 (2025-05-29)\n */\n\n(function () {\n    'use strict';\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const hasProto = (v, constructor, predicate) => {\n        var _a;\n        if (predicate(v, constructor.prototype)) {\n            return true;\n        }\n        else {\n            // String-based fallback time\n            return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n        }\n    };\n    const typeOf = (x) => {\n        const t = typeof x;\n        if (x === null) {\n            return 'null';\n        }\n        else if (t === 'object' && Array.isArray(x)) {\n            return 'array';\n        }\n        else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n            return 'string';\n        }\n        else {\n            return t;\n        }\n    };\n    const isType$1 = (type) => (value) => typeOf(value) === type;\n    const isSimpleType = (type) => (value) => typeof value === type;\n    const isString = isType$1('string');\n    const isArray = isType$1('array');\n    const isBoolean = isSimpleType('boolean');\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n    const isNumber = isSimpleType('number');\n\n    const noop = () => { };\n    const constant = (value) => {\n        return () => {\n            return value;\n        };\n    };\n    const always = constant(true);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n    // Sneaky optimisation: every instance of Optional.none is identical, so just\n    // reuse the same object\n    Optional.singletonNone = new Optional(false);\n\n    /* eslint-disable @typescript-eslint/unbound-method */\n    const nativeSlice = Array.prototype.slice;\n    const nativePush = Array.prototype.push;\n    const map = (xs, f) => {\n        // pre-allocating array size when it's guaranteed to be known\n        // http://jsperf.com/push-allocated-vs-dynamic/22\n        const len = xs.length;\n        const r = new Array(len);\n        for (let i = 0; i < len; i++) {\n            const x = xs[i];\n            r[i] = f(x, i);\n        }\n        return r;\n    };\n    // Unwound implementing other functions in terms of each.\n    // The code size is roughly the same, and it should allow for better optimisation.\n    // const each = function<T, U>(xs: T[], f: (x: T, i?: number, xs?: T[]) => void): void {\n    const each = (xs, f) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    const eachr = (xs, f) => {\n        for (let i = xs.length - 1; i >= 0; i--) {\n            const x = xs[i];\n            f(x, i);\n        }\n    };\n    /*\n     * Groups an array into contiguous arrays of like elements. Whether an element is like or not depends on f.\n     *\n     * f is a function that derives a value from an element - e.g. true or false, or a string.\n     * Elements are like if this function generates the same value for them (according to ===).\n     *\n     *\n     * Order of the elements is preserved. Arr.flatten() on the result will return the original list, as with Haskell groupBy function.\n     *  For a good explanation, see the group function (which is a special case of groupBy)\n     *  http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-List.html#v:group\n     */\n    const groupBy = (xs, f) => {\n        if (xs.length === 0) {\n            return [];\n        }\n        else {\n            let wasType = f(xs[0]); // initial case for matching\n            const r = [];\n            let group = [];\n            for (let i = 0, len = xs.length; i < len; i++) {\n                const x = xs[i];\n                const type = f(x);\n                if (type !== wasType) {\n                    r.push(group);\n                    group = [];\n                }\n                wasType = type;\n                group.push(x);\n            }\n            if (group.length !== 0) {\n                r.push(group);\n            }\n            return r;\n        }\n    };\n    const foldl = (xs, f, acc) => {\n        each(xs, (x, i) => {\n            acc = f(acc, x, i);\n        });\n        return acc;\n    };\n    const flatten = (xs) => {\n        // Note, this is possible because push supports multiple arguments:\n        // http://jsperf.com/concat-push/6\n        // Note that in the past, concat() would silently work (very slowly) for array-like objects.\n        // With this change it will throw an error.\n        const r = [];\n        for (let i = 0, len = xs.length; i < len; ++i) {\n            // Ensure that each value is an array itself\n            if (!isArray(xs[i])) {\n                throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n            }\n            nativePush.apply(r, xs[i]);\n        }\n        return r;\n    };\n    const bind = (xs, f) => flatten(map(xs, f));\n    const sort = (xs, comparator) => {\n        const copy = nativeSlice.call(xs, 0);\n        copy.sort(comparator);\n        return copy;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const hasOwnProperty = Object.hasOwnProperty;\n    const has = (obj, key) => hasOwnProperty.call(obj, key);\n\n    const Cell = (initial) => {\n        let value = initial;\n        const get = () => {\n            return value;\n        };\n        const set = (v) => {\n            value = v;\n        };\n        return {\n            get,\n            set\n        };\n    };\n\n    const singleton = (doRevoke) => {\n        const subject = Cell(Optional.none());\n        const revoke = () => subject.get().each(doRevoke);\n        const clear = () => {\n            revoke();\n            subject.set(Optional.none());\n        };\n        const isSet = () => subject.get().isSome();\n        const get = () => subject.get();\n        const set = (s) => {\n            revoke();\n            subject.set(Optional.some(s));\n        };\n        return {\n            clear,\n            isSet,\n            get,\n            set\n        };\n    };\n    const value = () => {\n        const subject = singleton(noop);\n        const on = (f) => subject.get().each(f);\n        return {\n            ...subject,\n            on\n        };\n    };\n\n    var global$3 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    /* eslint-disable max-len */\n    const punctuationStr = `[~№|!-*+-\\\\/:;?@\\\\[-\\`{}\\u00A1\\u00AB\\u00B7\\u00BB\\u00BF;\\u00B7\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1361-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u3008\\u3009\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30\\u2E31\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]`;\n\n    const punctuation$1 = constant(punctuationStr);\n\n    // tslint:disable-next-line:variable-name\n    const Custom = (regex, prefix, suffix, flags) => {\n        const term = () => {\n            return new RegExp(regex, flags.getOr('g'));\n        };\n        return {\n            term,\n            prefix,\n            suffix\n        };\n    };\n\n    Custom;\n    const punctuation = punctuation$1;\n\n    var global$2 = tinymce.util.Tools.resolve('tinymce.Env');\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const fromHtml = (html, scope) => {\n        const doc = scope || document;\n        const div = doc.createElement('div');\n        div.innerHTML = html;\n        if (!div.hasChildNodes() || div.childNodes.length > 1) {\n            const message = 'HTML does not have a single root node';\n            // eslint-disable-next-line no-console\n            console.error(message, html);\n            throw new Error(message);\n        }\n        return fromDom(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n        const doc = scope || document;\n        const node = doc.createElement(tag);\n        return fromDom(node);\n    };\n    const fromText = (text, scope) => {\n        const doc = scope || document;\n        const node = doc.createTextNode(text);\n        return fromDom(node);\n    };\n    const fromDom = (node) => {\n        // TODO: Consider removing this check, but left atm for safety\n        if (node === null || node === undefined) {\n            throw new Error('Node cannot be null or undefined');\n        }\n        return {\n            dom: node\n        };\n    };\n    const fromPoint = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom);\n    // tslint:disable-next-line:variable-name\n    const SugarElement = {\n        fromHtml,\n        fromTag,\n        fromText,\n        fromDom,\n        fromPoint\n    };\n\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const bypassSelector = (dom) => \n    // Only elements, documents and shadow roots support querySelector\n    // shadow root element type is DOCUMENT_FRAGMENT\n    dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT ||\n        // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/\n        dom.childElementCount === 0;\n    const all = (selector, scope) => {\n        const base = scope === undefined ? document : scope.dom;\n        return bypassSelector(base) ? [] : map(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n\n    /*\n     * Most of sand doesn't alter the methods on the object.\n     * We're making an exception for Node, because bitwise and is so easy to get wrong.\n     *\n     * Might be nice to ADT this at some point instead of having individual methods.\n     */\n    const compareDocumentPosition = (a, b, match) => {\n        // Returns: 0 if e1 and e2 are the same node, or a bitmask comparing the positions\n        // of nodes e1 and e2 in their documents. See the URL below for bitmask interpretation\n        // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        // eslint-disable-next-line no-bitwise\n        return (a.compareDocumentPosition(b) & match) !== 0;\n    };\n    const documentPositionPreceding = (a, b) => {\n        return compareDocumentPosition(a, b, Node.DOCUMENT_POSITION_PRECEDING);\n    };\n\n    const type = (element) => element.dom.nodeType;\n    const isType = (t) => (element) => type(element) === t;\n    const isText$1 = isType(TEXT);\n\n    const parent = (element) => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const children = (element) => map(element.dom.childNodes, SugarElement.fromDom);\n    const spot = (element, offset) => ({\n        element,\n        offset\n    });\n    const leaf = (element, offset) => {\n        const cs = children(element);\n        return cs.length > 0 && offset < cs.length ? spot(cs[offset], 0) : spot(element, offset);\n    };\n\n    const before = (marker, element) => {\n        const parent$1 = parent(marker);\n        parent$1.each((v) => {\n            v.dom.insertBefore(element.dom, marker.dom);\n        });\n    };\n    const append = (parent, element) => {\n        parent.dom.appendChild(element.dom);\n    };\n    const wrap = (element, wrapper) => {\n        before(element, wrapper);\n        append(wrapper, element);\n    };\n\n    const rawSet = (dom, key, value) => {\n        /*\n         * JQuery coerced everything to a string, and silently did nothing on text node/null/undefined.\n         *\n         * We fail on those invalid cases, only allowing numbers and booleans.\n         */\n        if (isString(value) || isBoolean(value) || isNumber(value)) {\n            dom.setAttribute(key, value + '');\n        }\n        else {\n            // eslint-disable-next-line no-console\n            console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n            throw new Error('Attribute value was not simple');\n        }\n    };\n    const set = (element, key, value) => {\n        rawSet(element.dom, key, value);\n    };\n\n    const NodeValue = (is, name) => {\n        const get = (element) => {\n            if (!is(element)) {\n                throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n            }\n            return getOption(element).getOr('');\n        };\n        const getOption = (element) => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n        const set = (element, value) => {\n            if (!is(element)) {\n                throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n            }\n            element.dom.nodeValue = value;\n        };\n        return {\n            get,\n            getOption,\n            set\n        };\n    };\n\n    const api = NodeValue(isText$1, 'text');\n    const get$1 = (element) => api.get(element);\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    var global = tinymce.util.Tools.resolve('tinymce.dom.TreeWalker');\n\n    const isSimpleBoundary = (dom, node) => dom.isBlock(node) || has(dom.schema.getVoidElements(), node.nodeName);\n    const isContentEditableFalse = (dom, node) => !dom.isEditable(node);\n    const isContentEditableTrueInCef = (dom, node) => dom.getContentEditable(node) === 'true' && node.parentNode && !dom.isEditable(node.parentNode);\n    const isHidden = (dom, node) => !dom.isBlock(node) && has(dom.schema.getWhitespaceElements(), node.nodeName);\n    const isBoundary = (dom, node) => isSimpleBoundary(dom, node) || isContentEditableFalse(dom, node) || isHidden(dom, node) || isContentEditableTrueInCef(dom, node);\n    const isText = (node) => node.nodeType === 3;\n    const nuSection = () => ({\n        sOffset: 0,\n        fOffset: 0,\n        elements: []\n    });\n    const toLeaf = (node, offset) => leaf(SugarElement.fromDom(node), offset);\n    const walk = (dom, walkerFn, startNode, callbacks, endNode, skipStart = true) => {\n        let next = skipStart ? walkerFn(false) : startNode;\n        while (next) {\n            // Walk over content editable or hidden elements\n            const isCefNode = isContentEditableFalse(dom, next);\n            if (isCefNode || isHidden(dom, next)) {\n                const stopWalking = isCefNode ? callbacks.cef(next) : callbacks.boundary(next);\n                if (stopWalking) {\n                    break;\n                }\n                else {\n                    next = walkerFn(true);\n                    continue;\n                }\n            }\n            else if (isSimpleBoundary(dom, next)) {\n                if (callbacks.boundary(next)) {\n                    break;\n                }\n            }\n            else if (isText(next)) {\n                callbacks.text(next);\n            }\n            if (next === endNode) {\n                break;\n            }\n            else {\n                next = walkerFn(false);\n            }\n        }\n    };\n    const collectTextToBoundary = (dom, section, node, rootNode, forwards) => {\n        var _a;\n        // Don't bother collecting text nodes if we're already at a boundary\n        if (isBoundary(dom, node)) {\n            return;\n        }\n        const rootBlock = (_a = dom.getParent(rootNode, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n        const walker = new global(node, rootBlock);\n        const walkerFn = forwards ? walker.next.bind(walker) : walker.prev.bind(walker);\n        // Walk over and add text nodes to the section and increase the offsets\n        // so we know to ignore the additional text when matching\n        walk(dom, walkerFn, node, {\n            boundary: always,\n            cef: always,\n            text: (next) => {\n                if (forwards) {\n                    section.fOffset += next.length;\n                }\n                else {\n                    section.sOffset += next.length;\n                }\n                section.elements.push(SugarElement.fromDom(next));\n            }\n        });\n    };\n    const collect = (dom, rootNode, startNode, endNode, callbacks, skipStart = true) => {\n        const walker = new global(startNode, rootNode);\n        const sections = [];\n        let current = nuSection();\n        // Find any text between the start node and the closest boundary\n        collectTextToBoundary(dom, current, startNode, rootNode, false);\n        const finishSection = () => {\n            if (current.elements.length > 0) {\n                sections.push(current);\n                current = nuSection();\n            }\n            return false;\n        };\n        // Collect all the text nodes in the specified range and create sections from the\n        // boundaries within the range\n        walk(dom, walker.next.bind(walker), startNode, {\n            boundary: finishSection,\n            cef: (node) => {\n                finishSection();\n                // Collect additional nested contenteditable true content\n                if (callbacks) {\n                    sections.push(...callbacks.cef(node));\n                }\n                return false;\n            },\n            text: (next) => {\n                current.elements.push(SugarElement.fromDom(next));\n                if (callbacks) {\n                    callbacks.text(next, current);\n                }\n            }\n        }, endNode, skipStart);\n        // Find any text between the end node and the closest boundary, then finalise the section\n        if (endNode) {\n            collectTextToBoundary(dom, current, endNode, rootNode, true);\n        }\n        finishSection();\n        return sections;\n    };\n    const collectRangeSections = (dom, rng) => {\n        const start = toLeaf(rng.startContainer, rng.startOffset);\n        const startNode = start.element.dom;\n        const end = toLeaf(rng.endContainer, rng.endOffset);\n        const endNode = end.element.dom;\n        return collect(dom, rng.commonAncestorContainer, startNode, endNode, {\n            text: (node, section) => {\n                // Set the start/end offset of the section\n                if (node === endNode) {\n                    section.fOffset += node.length - end.offset;\n                }\n                else if (node === startNode) {\n                    section.sOffset += start.offset;\n                }\n            },\n            cef: (node) => {\n                // Collect the sections and then order them appropriately, as nested sections maybe out of order\n                // TODO: See if we can improve this to avoid the sort overhead\n                const sections = bind(descendants(SugarElement.fromDom(node), '*[contenteditable=true]'), (e) => {\n                    const ceTrueNode = e.dom;\n                    return collect(dom, ceTrueNode, ceTrueNode);\n                });\n                return sort(sections, (a, b) => (documentPositionPreceding(a.elements[0].dom, b.elements[0].dom)) ? 1 : -1);\n            }\n        }, false);\n    };\n    const fromRng = (dom, rng) => rng.collapsed ? [] : collectRangeSections(dom, rng);\n    const fromNode = (dom, node) => {\n        const rng = dom.createRng();\n        rng.selectNode(node);\n        return fromRng(dom, rng);\n    };\n    const fromNodes = (dom, nodes) => bind(nodes, (node) => fromNode(dom, node));\n\n    const find$2 = (text, pattern, start = 0, finish = text.length) => {\n        const regex = pattern.regex;\n        regex.lastIndex = start;\n        const results = [];\n        let match;\n        while ((match = regex.exec(text))) {\n            const matchedText = match[pattern.matchIndex];\n            const matchStart = match.index + match[0].indexOf(matchedText);\n            const matchFinish = matchStart + matchedText.length;\n            // Stop finding matches if we've hit the finish mark\n            if (matchFinish > finish) {\n                break;\n            }\n            results.push({\n                start: matchStart,\n                finish: matchFinish\n            });\n            regex.lastIndex = matchFinish;\n        }\n        return results;\n    };\n    const extract = (elements, matches) => {\n        // Walk over each text node and compare with the matches\n        const nodePositions = foldl(elements, (acc, element) => {\n            const content = get$1(element);\n            const start = acc.last;\n            const finish = start + content.length;\n            // Find positions for any matches in the current text node\n            const positions = bind(matches, (match, matchIdx) => {\n                // Check to see if the match overlaps with the text position\n                if (match.start < finish && match.finish > start) {\n                    return [{\n                            element,\n                            start: Math.max(start, match.start) - start,\n                            finish: Math.min(finish, match.finish) - start,\n                            matchId: matchIdx\n                        }];\n                }\n                else {\n                    return [];\n                }\n            });\n            return {\n                results: acc.results.concat(positions),\n                last: finish\n            };\n        }, { results: [], last: 0 }).results;\n        // Group the positions by the match id\n        return groupBy(nodePositions, (position) => position.matchId);\n    };\n\n    const find$1 = (pattern, sections) => bind(sections, (section) => {\n        const elements = section.elements;\n        const content = map(elements, get$1).join('');\n        const positions = find$2(content, pattern, section.sOffset, content.length - section.fOffset);\n        return extract(elements, positions);\n    });\n    const mark = (matches, replacementNode) => {\n        // Walk backwards and mark the positions\n        // Note: We need to walk backwards so the position indexes don't change\n        eachr(matches, (match, idx) => {\n            eachr(match, (pos) => {\n                const wrapper = SugarElement.fromDom(replacementNode.cloneNode(false));\n                set(wrapper, 'data-mce-index', idx);\n                const textNode = pos.element.dom;\n                if (textNode.length === pos.finish && pos.start === 0) {\n                    wrap(pos.element, wrapper);\n                }\n                else {\n                    if (textNode.length !== pos.finish) {\n                        textNode.splitText(pos.finish);\n                    }\n                    const matchNode = textNode.splitText(pos.start);\n                    wrap(SugarElement.fromDom(matchNode), wrapper);\n                }\n            });\n        });\n    };\n    const findAndMark = (dom, pattern, node, replacementNode) => {\n        const textSections = fromNode(dom, node);\n        const matches = find$1(pattern, textSections);\n        mark(matches, replacementNode);\n        return matches.length;\n    };\n    const findAndMarkInSelection = (dom, pattern, selection, replacementNode) => {\n        const bookmark = selection.getBookmark();\n        // Handle table cell selection as the table plugin enables\n        // you to fake select table cells and perform actions on them\n        const nodes = dom.select('td[data-mce-selected],th[data-mce-selected]');\n        const textSections = nodes.length > 0 ? fromNodes(dom, nodes) : fromRng(dom, selection.getRng());\n        // Find and mark matches\n        const matches = find$1(pattern, textSections);\n        mark(matches, replacementNode);\n        // Restore the selection\n        selection.moveToBookmark(bookmark);\n        return matches.length;\n    };\n\n    const getElmIndex = (elm) => {\n        return elm.getAttribute('data-mce-index');\n    };\n    const markAllMatches = (editor, currentSearchState, pattern, inSelection) => {\n        const marker = editor.dom.create('span', {\n            'data-mce-bogus': 1\n        });\n        marker.className = 'mce-match-marker';\n        const node = editor.getBody();\n        done(editor, currentSearchState, false);\n        if (inSelection) {\n            return findAndMarkInSelection(editor.dom, pattern, editor.selection, marker);\n        }\n        else {\n            return findAndMark(editor.dom, pattern, node, marker);\n        }\n    };\n    const unwrap = (node) => {\n        var _a;\n        const parentNode = node.parentNode;\n        if (node.firstChild) {\n            parentNode.insertBefore(node.firstChild, node);\n        }\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(node);\n    };\n    const findSpansByIndex = (editor, index) => {\n        const spans = [];\n        const nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));\n        if (nodes.length) {\n            for (let i = 0; i < nodes.length; i++) {\n                const nodeIndex = getElmIndex(nodes[i]);\n                if (nodeIndex === null || !nodeIndex.length) {\n                    continue;\n                }\n                if (nodeIndex === index.toString()) {\n                    spans.push(nodes[i]);\n                }\n            }\n        }\n        return spans;\n    };\n    const moveSelection = (editor, currentSearchState, forward) => {\n        const searchState = currentSearchState.get();\n        let testIndex = searchState.index;\n        const dom = editor.dom;\n        if (forward) {\n            if (testIndex + 1 === searchState.count) {\n                testIndex = 0;\n            }\n            else {\n                testIndex++;\n            }\n        }\n        else {\n            if (testIndex - 1 === -1) {\n                testIndex = searchState.count - 1;\n            }\n            else {\n                testIndex--;\n            }\n        }\n        dom.removeClass(findSpansByIndex(editor, searchState.index), 'mce-match-marker-selected');\n        const spans = findSpansByIndex(editor, testIndex);\n        if (spans.length) {\n            dom.addClass(findSpansByIndex(editor, testIndex), 'mce-match-marker-selected');\n            editor.selection.scrollIntoView(spans[0]);\n            return testIndex;\n        }\n        return -1;\n    };\n    const removeNode = (dom, node) => {\n        const parent = node.parentNode;\n        dom.remove(node);\n        if (parent && dom.isEmpty(parent)) {\n            dom.remove(parent);\n        }\n    };\n    const escapeSearchText = (text, wholeWord) => {\n        const escapedText = text.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&').replace(/\\s/g, '[^\\\\S\\\\r\\\\n\\\\uFEFF]');\n        const wordRegex = '(' + escapedText + ')';\n        return wholeWord ? `(?:^|\\\\s|${punctuation()})` + wordRegex + `(?=$|\\\\s|${punctuation()})` : wordRegex;\n    };\n    const find = (editor, currentSearchState, text, matchCase, wholeWord, inSelection) => {\n        const selection = editor.selection;\n        const escapedText = escapeSearchText(text, wholeWord);\n        const isForwardSelection = selection.isForward();\n        const pattern = {\n            regex: new RegExp(escapedText, matchCase ? 'g' : 'gi'),\n            matchIndex: 1\n        };\n        const count = markAllMatches(editor, currentSearchState, pattern, inSelection);\n        // Safari has a bug whereby splitting text nodes breaks the selection (which is done when marking matches).\n        // As such we need to manually reset it after doing a find action. See https://bugs.webkit.org/show_bug.cgi?id=230594\n        if (global$2.browser.isSafari()) {\n            selection.setRng(selection.getRng(), isForwardSelection);\n        }\n        if (count) {\n            const newIndex = moveSelection(editor, currentSearchState, true);\n            currentSearchState.set({\n                index: newIndex,\n                count,\n                text,\n                matchCase,\n                wholeWord,\n                inSelection\n            });\n        }\n        return count;\n    };\n    const next = (editor, currentSearchState) => {\n        const index = moveSelection(editor, currentSearchState, true);\n        currentSearchState.set({ ...currentSearchState.get(), index });\n    };\n    const prev = (editor, currentSearchState) => {\n        const index = moveSelection(editor, currentSearchState, false);\n        currentSearchState.set({ ...currentSearchState.get(), index });\n    };\n    const isMatchSpan = (node) => {\n        const matchIndex = getElmIndex(node);\n        return matchIndex !== null && matchIndex.length > 0;\n    };\n    const replace = (editor, currentSearchState, text, forward, all) => {\n        const searchState = currentSearchState.get();\n        const currentIndex = searchState.index;\n        let currentMatchIndex, nextIndex = currentIndex;\n        forward = forward !== false;\n        const node = editor.getBody();\n        const nodes = global$1.grep(global$1.toArray(node.getElementsByTagName('span')), isMatchSpan);\n        for (let i = 0; i < nodes.length; i++) {\n            const nodeIndex = getElmIndex(nodes[i]);\n            let matchIndex = currentMatchIndex = parseInt(nodeIndex, 10);\n            if (all || matchIndex === searchState.index) {\n                if (text.length) {\n                    nodes[i].innerText = text;\n                    unwrap(nodes[i]);\n                }\n                else {\n                    removeNode(editor.dom, nodes[i]);\n                }\n                while (nodes[++i]) {\n                    matchIndex = parseInt(getElmIndex(nodes[i]), 10);\n                    if (matchIndex === currentMatchIndex) {\n                        removeNode(editor.dom, nodes[i]);\n                    }\n                    else {\n                        i--;\n                        break;\n                    }\n                }\n                if (forward) {\n                    nextIndex--;\n                }\n            }\n            else if (currentMatchIndex > currentIndex) {\n                nodes[i].setAttribute('data-mce-index', String(currentMatchIndex - 1));\n            }\n        }\n        currentSearchState.set({\n            ...searchState,\n            count: all ? 0 : searchState.count - 1,\n            index: nextIndex\n        });\n        if (forward) {\n            next(editor, currentSearchState);\n        }\n        else {\n            prev(editor, currentSearchState);\n        }\n        return !all && currentSearchState.get().count > 0;\n    };\n    const done = (editor, currentSearchState, keepEditorSelection) => {\n        let startContainer;\n        let endContainer;\n        const searchState = currentSearchState.get();\n        const nodes = global$1.toArray(editor.getBody().getElementsByTagName('span'));\n        for (let i = 0; i < nodes.length; i++) {\n            const nodeIndex = getElmIndex(nodes[i]);\n            if (nodeIndex !== null && nodeIndex.length) {\n                if (nodeIndex === searchState.index.toString()) {\n                    // Note: The first child of the span node will be the highlighted text node\n                    if (!startContainer) {\n                        startContainer = nodes[i].firstChild;\n                    }\n                    endContainer = nodes[i].firstChild;\n                }\n                unwrap(nodes[i]);\n            }\n        }\n        // Reset the search state\n        currentSearchState.set({\n            ...searchState,\n            index: -1,\n            count: 0,\n            text: ''\n        });\n        if (startContainer && endContainer) {\n            const rng = editor.dom.createRng();\n            rng.setStart(startContainer, 0);\n            rng.setEnd(endContainer, endContainer.data.length);\n            if (keepEditorSelection !== false) {\n                editor.selection.setRng(rng);\n            }\n            return rng;\n        }\n        else {\n            return undefined;\n        }\n    };\n    const hasNext = (editor, currentSearchState) => currentSearchState.get().count > 1;\n    const hasPrev = (editor, currentSearchState) => currentSearchState.get().count > 1;\n\n    const get = (editor, currentState) => {\n        const done$1 = (keepEditorSelection) => {\n            return done(editor, currentState, keepEditorSelection);\n        };\n        const find$1 = (text, matchCase, wholeWord, inSelection = false) => {\n            return find(editor, currentState, text, matchCase, wholeWord, inSelection);\n        };\n        const next$1 = () => {\n            return next(editor, currentState);\n        };\n        const prev$1 = () => {\n            return prev(editor, currentState);\n        };\n        const replace$1 = (text, forward, all) => {\n            return replace(editor, currentState, text, forward, all);\n        };\n        return {\n            done: done$1,\n            find: find$1,\n            next: next$1,\n            prev: prev$1,\n            replace: replace$1\n        };\n    };\n\n    const open = (editor, currentSearchState) => {\n        const dialogApi = value();\n        editor.undoManager.add();\n        const selectedText = global$1.trim(editor.selection.getContent({ format: 'text' }));\n        const updateButtonStates = (api) => {\n            api.setEnabled('next', hasNext(editor, currentSearchState));\n            api.setEnabled('prev', hasPrev(editor, currentSearchState));\n        };\n        const updateSearchState = (api) => {\n            const data = api.getData();\n            const current = currentSearchState.get();\n            currentSearchState.set({\n                ...current,\n                matchCase: data.matchcase,\n                wholeWord: data.wholewords,\n                inSelection: data.inselection\n            });\n        };\n        const disableAll = (api, disable) => {\n            const buttons = ['replace', 'replaceall', 'prev', 'next'];\n            const toggle = (name) => api.setEnabled(name, !disable);\n            each(buttons, toggle);\n        };\n        const toggleNotFoundAlert = (isVisible, api) => {\n            api.redial(getDialogSpec(isVisible, api.getData()));\n        };\n        // Temporarily workaround for iOS/iPadOS dialog placement to hide the keyboard\n        // TODO: Remove in 5.2 once iOS fixed positioning is fixed. See TINY-4441\n        const focusButtonIfRequired = (api, name) => {\n            if (global$2.browser.isSafari() && global$2.deviceType.isTouch() && (name === 'find' || name === 'replace' || name === 'replaceall')) {\n                api.focus(name);\n            }\n        };\n        const reset = (api) => {\n            // Clean up the markers if required\n            done(editor, currentSearchState, false);\n            // Disable the buttons\n            disableAll(api, true);\n            updateButtonStates(api);\n        };\n        const doFind = (api) => {\n            const data = api.getData();\n            const last = currentSearchState.get();\n            if (!data.findtext.length) {\n                reset(api);\n                return;\n            }\n            // Same search text, so treat the find as a next click instead\n            if (last.text === data.findtext && last.matchCase === data.matchcase && last.wholeWord === data.wholewords) {\n                next(editor, currentSearchState);\n            }\n            else {\n                // Find new matches\n                const count = find(editor, currentSearchState, data.findtext, data.matchcase, data.wholewords, data.inselection);\n                if (count <= 0) {\n                    toggleNotFoundAlert(true, api);\n                }\n                disableAll(api, count === 0);\n            }\n            updateButtonStates(api);\n        };\n        const initialState = currentSearchState.get();\n        const initialData = {\n            findtext: selectedText,\n            replacetext: '',\n            wholewords: initialState.wholeWord,\n            matchcase: initialState.matchCase,\n            inselection: initialState.inSelection\n        };\n        const getPanelItems = (error) => {\n            const items = [\n                {\n                    type: 'label',\n                    label: 'Find',\n                    for: 'findtext',\n                    items: [\n                        {\n                            type: 'bar',\n                            items: [\n                                {\n                                    type: 'input',\n                                    name: 'findtext',\n                                    maximized: true,\n                                    inputMode: 'search'\n                                },\n                                {\n                                    type: 'button',\n                                    name: 'prev',\n                                    text: 'Previous',\n                                    icon: 'action-prev',\n                                    enabled: false,\n                                    borderless: true\n                                },\n                                {\n                                    type: 'button',\n                                    name: 'next',\n                                    text: 'Next',\n                                    icon: 'action-next',\n                                    enabled: false,\n                                    borderless: true\n                                }\n                            ]\n                        }\n                    ]\n                },\n                {\n                    type: 'input',\n                    name: 'replacetext',\n                    label: 'Replace with',\n                    inputMode: 'search'\n                },\n            ];\n            if (error) {\n                items.push({\n                    type: 'alertbanner',\n                    level: 'error',\n                    text: 'Could not find the specified string.',\n                    icon: 'warning',\n                });\n            }\n            return items;\n        };\n        const getDialogSpec = (showNoMatchesAlertBanner, initialData) => ({\n            title: 'Find and Replace',\n            size: 'normal',\n            body: {\n                type: 'panel',\n                items: getPanelItems(showNoMatchesAlertBanner)\n            },\n            buttons: [\n                {\n                    type: 'menu',\n                    name: 'options',\n                    icon: 'preferences',\n                    tooltip: 'Preferences',\n                    align: 'start',\n                    items: [\n                        {\n                            type: 'togglemenuitem',\n                            name: 'matchcase',\n                            text: 'Match case'\n                        }, {\n                            type: 'togglemenuitem',\n                            name: 'wholewords',\n                            text: 'Find whole words only'\n                        },\n                        {\n                            type: 'togglemenuitem',\n                            name: 'inselection',\n                            text: 'Find in selection'\n                        }\n                    ]\n                },\n                {\n                    type: 'custom',\n                    name: 'find',\n                    text: 'Find',\n                    primary: true\n                },\n                {\n                    type: 'custom',\n                    name: 'replace',\n                    text: 'Replace',\n                    enabled: false\n                },\n                {\n                    type: 'custom',\n                    name: 'replaceall',\n                    text: 'Replace all',\n                    enabled: false,\n                }\n            ],\n            initialData,\n            onChange: (api, details) => {\n                if (showNoMatchesAlertBanner) {\n                    toggleNotFoundAlert(false, api);\n                }\n                if (details.name === 'findtext' && currentSearchState.get().count > 0) {\n                    reset(api);\n                }\n            },\n            onAction: (api, details) => {\n                const data = api.getData();\n                switch (details.name) {\n                    case 'find':\n                        doFind(api);\n                        break;\n                    case 'replace':\n                        if (!replace(editor, currentSearchState, data.replacetext)) {\n                            reset(api);\n                        }\n                        else {\n                            updateButtonStates(api);\n                        }\n                        break;\n                    case 'replaceall':\n                        replace(editor, currentSearchState, data.replacetext, true, true);\n                        reset(api);\n                        break;\n                    case 'prev':\n                        prev(editor, currentSearchState);\n                        updateButtonStates(api);\n                        break;\n                    case 'next':\n                        next(editor, currentSearchState);\n                        updateButtonStates(api);\n                        break;\n                    case 'matchcase':\n                    case 'wholewords':\n                    case 'inselection':\n                        toggleNotFoundAlert(false, api);\n                        updateSearchState(api);\n                        reset(api);\n                        break;\n                }\n                focusButtonIfRequired(api, details.name);\n            },\n            onSubmit: (api) => {\n                doFind(api);\n                focusButtonIfRequired(api, 'find');\n            },\n            onClose: () => {\n                editor.focus();\n                done(editor, currentSearchState);\n                editor.undoManager.add();\n            }\n        });\n        dialogApi.set(editor.windowManager.open(getDialogSpec(false, initialData), { inline: 'toolbar' }));\n    };\n\n    const register$1 = (editor, currentSearchState) => {\n        editor.addCommand('SearchReplace', () => {\n            open(editor, currentSearchState);\n        });\n    };\n\n    const showDialog = (editor, currentSearchState) => () => {\n        open(editor, currentSearchState);\n    };\n    const register = (editor, currentSearchState) => {\n        editor.ui.registry.addMenuItem('searchreplace', {\n            text: 'Find and replace...',\n            shortcut: 'Meta+F',\n            onAction: showDialog(editor, currentSearchState),\n            icon: 'search'\n        });\n        editor.ui.registry.addButton('searchreplace', {\n            tooltip: 'Find and replace',\n            onAction: showDialog(editor, currentSearchState),\n            icon: 'search',\n            shortcut: 'Meta+F'\n        });\n        editor.shortcuts.add('Meta+F', '', showDialog(editor, currentSearchState));\n    };\n\n    var Plugin = () => {\n        global$3.add('searchreplace', (editor) => {\n            const currentSearchState = Cell({\n                index: -1,\n                count: 0,\n                text: '',\n                matchCase: false,\n                wholeWord: false,\n                inSelection: false\n            });\n            register$1(editor, currentSearchState);\n            register(editor, currentSearchState);\n            return get(editor, currentSearchState);\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n", "// Exports the \"searchreplace\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/searchreplace')\n//   ES2015:\n//     import 'tinymce/plugins/searchreplace'\nrequire('./plugin.js');"],
  "mappings": "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",
  "names": ["type", "value", "get", "set", "parent", "next", "all", "find$1", "api", "initialData"]
}
