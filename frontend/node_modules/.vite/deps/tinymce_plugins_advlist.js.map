{
  "version": 3,
  "sources": ["../../tinymce/plugins/advlist/plugin.js", "../../tinymce/plugins/advlist/index.js"],
  "sourcesContent": ["/**\n * TinyMCE version 7.9.1 (2025-05-29)\n */\n\n(function () {\n    'use strict';\n\n    var global$1 = tinymce.util.Tools.resolve('tinymce.PluginManager');\n\n    const applyListFormat = (editor, listName, styleValue) => {\n        const cmd = listName === 'UL' ? 'InsertUnorderedList' : 'InsertOrderedList';\n        editor.execCommand(cmd, false, styleValue === false ? null : { 'list-style-type': styleValue });\n    };\n\n    const register$2 = (editor) => {\n        editor.addCommand('ApplyUnorderedListStyle', (ui, value) => {\n            applyListFormat(editor, 'UL', value['list-style-type']);\n        });\n        editor.addCommand('ApplyOrderedListStyle', (ui, value) => {\n            applyListFormat(editor, 'OL', value['list-style-type']);\n        });\n    };\n\n    const option = (name) => (editor) => editor.options.get(name);\n    const register$1 = (editor) => {\n        const registerOption = editor.options.register;\n        registerOption('advlist_number_styles', {\n            processor: 'string[]',\n            default: 'default,lower-alpha,lower-greek,lower-roman,upper-alpha,upper-roman'.split(',')\n        });\n        registerOption('advlist_bullet_styles', {\n            processor: 'string[]',\n            default: 'default,disc,circle,square'.split(',')\n        });\n    };\n    const getNumberStyles = option('advlist_number_styles');\n    const getBulletStyles = option('advlist_bullet_styles');\n\n    /* eslint-disable @typescript-eslint/no-wrapper-object-types */\n    const isNullable = (a) => a === null || a === undefined;\n    const isNonNullable = (a) => !isNullable(a);\n\n    /**\n     * The `Optional` type represents a value (of any type) that potentially does\n     * not exist. Any `Optional<T>` can either be a `Some<T>` (in which case the\n     * value does exist) or a `None` (in which case the value does not exist). This\n     * module defines a whole lot of FP-inspired utility functions for dealing with\n     * `Optional` objects.\n     *\n     * Comparison with null or undefined:\n     * - We don't get fancy null coalescing operators with `Optional`\n     * - We do get fancy helper functions with `Optional`\n     * - `Optional` support nesting, and allow for the type to still be nullable (or\n     * another `Optional`)\n     * - There is no option to turn off strict-optional-checks like there is for\n     * strict-null-checks\n     */\n    class Optional {\n        // The internal representation has a `tag` and a `value`, but both are\n        // private: able to be console.logged, but not able to be accessed by code\n        constructor(tag, value) {\n            this.tag = tag;\n            this.value = value;\n        }\n        // --- Identities ---\n        /**\n         * Creates a new `Optional<T>` that **does** contain a value.\n         */\n        static some(value) {\n            return new Optional(true, value);\n        }\n        /**\n         * Create a new `Optional<T>` that **does not** contain a value. `T` can be\n         * any type because we don't actually have a `T`.\n         */\n        static none() {\n            return Optional.singletonNone;\n        }\n        /**\n         * Perform a transform on an `Optional` type. Regardless of whether this\n         * `Optional` contains a value or not, `fold` will return a value of type `U`.\n         * If this `Optional` does not contain a value, the `U` will be created by\n         * calling `onNone`. If this `Optional` does contain a value, the `U` will be\n         * created by calling `onSome`.\n         *\n         * For the FP enthusiasts in the room, this function:\n         * 1. Could be used to implement all of the functions below\n         * 2. Forms a catamorphism\n         */\n        fold(onNone, onSome) {\n            if (this.tag) {\n                return onSome(this.value);\n            }\n            else {\n                return onNone();\n            }\n        }\n        /**\n         * Determine if this `Optional` object contains a value.\n         */\n        isSome() {\n            return this.tag;\n        }\n        /**\n         * Determine if this `Optional` object **does not** contain a value.\n         */\n        isNone() {\n            return !this.tag;\n        }\n        // --- Functor (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value. If\n         * you provide a function to turn a T into a U, this is the function you use\n         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain\n         * a value then the output will also contain a value (that value being the\n         * output of `mapper(this.value)`), and if this **does not** contain a value\n         * then neither will the output.\n         */\n        map(mapper) {\n            if (this.tag) {\n                return Optional.some(mapper(this.value));\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Monad (name stolen from Haskell / maths) ---\n        /**\n         * Perform a transform on an `Optional` object, **if** there is a value.\n         * Unlike `map`, here the transform itself also returns an `Optional`.\n         */\n        bind(binder) {\n            if (this.tag) {\n                return binder(this.value);\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Traversable (name stolen from Haskell / maths) ---\n        /**\n         * For a given predicate, this function finds out if there **exists** a value\n         * inside this `Optional` object that meets the predicate. In practice, this\n         * means that for `Optional`s that do not contain a value it returns false (as\n         * no predicate-meeting value exists).\n         */\n        exists(predicate) {\n            return this.tag && predicate(this.value);\n        }\n        /**\n         * For a given predicate, this function finds out if **all** the values inside\n         * this `Optional` object meet the predicate. In practice, this means that\n         * for `Optional`s that do not contain a value it returns true (as all 0\n         * objects do meet the predicate).\n         */\n        forall(predicate) {\n            return !this.tag || predicate(this.value);\n        }\n        filter(predicate) {\n            if (!this.tag || predicate(this.value)) {\n                return this;\n            }\n            else {\n                return Optional.none();\n            }\n        }\n        // --- Getters ---\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.\n         */\n        getOr(replacement) {\n            return this.tag ? this.value : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value.  Unlike `getOr`, in this method the `replacement` object is also\n         * `Optional` - meaning that this method will always return an `Optional`.\n         */\n        or(replacement) {\n            return this.tag ? this : replacement;\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided `Optional` object does not contain a\n         * value. Unlike `getOr`, in this method the `replacement` value is\n         * \"thunked\" - that is to say that you don't pass a value to `getOrThunk`, you\n         * pass a function which (if called) will **return** the `value` you want to\n         * use.\n         */\n        getOrThunk(thunk) {\n            return this.tag ? this.value : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, using a default\n         * `replacement` value if the provided Optional object does not contain a\n         * value.\n         *\n         * Unlike `or`, in this method the `replacement` value is \"thunked\" - that is\n         * to say that you don't pass a value to `orThunk`, you pass a function which\n         * (if called) will **return** the `value` you want to use.\n         *\n         * Unlike `getOrThunk`, in this method the `replacement` value is also\n         * `Optional`, meaning that this method will always return an `Optional`.\n         */\n        orThunk(thunk) {\n            return this.tag ? this : thunk();\n        }\n        /**\n         * Get the value out of the inside of the `Optional` object, throwing an\n         * exception if the provided `Optional` object does not contain a value.\n         *\n         * WARNING:\n         * You should only be using this function if you know that the `Optional`\n         * object **is not** empty (otherwise you're throwing exceptions in production\n         * code, which is bad).\n         *\n         * In tests this is more acceptable.\n         *\n         * Prefer other methods to this, such as `.each`.\n         */\n        getOrDie(message) {\n            if (!this.tag) {\n                throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n            }\n            else {\n                return this.value;\n            }\n        }\n        // --- Interop with null and undefined ---\n        /**\n         * Creates an `Optional` value from a nullable (or undefined-able) input.\n         * Null, or undefined, is converted to `None`, and anything else is converted\n         * to `Some`.\n         */\n        static from(value) {\n            return isNonNullable(value) ? Optional.some(value) : Optional.none();\n        }\n        /**\n         * Converts an `Optional` to a nullable type, by getting the value if it\n         * exists, or returning `null` if it does not.\n         */\n        getOrNull() {\n            return this.tag ? this.value : null;\n        }\n        /**\n         * Converts an `Optional` to an undefined-able type, by getting the value if\n         * it exists, or returning `undefined` if it does not.\n         */\n        getOrUndefined() {\n            return this.value;\n        }\n        // --- Utilities ---\n        /**\n         * If the `Optional` contains a value, perform an action on that value.\n         * Unlike the rest of the methods on this type, `.each` has side-effects. If\n         * you want to transform an `Optional<T>` **into** something, then this is not\n         * the method for you. If you want to use an `Optional<T>` to **do**\n         * something, then this is the method for you - provided you're okay with not\n         * doing anything in the case where the `Optional` doesn't have a value inside\n         * it. If you're not sure whether your use-case fits into transforming\n         * **into** something or **doing** something, check whether it has a return\n         * value. If it does, you should be performing a transform.\n         */\n        each(worker) {\n            if (this.tag) {\n                worker(this.value);\n            }\n        }\n        /**\n         * Turn the `Optional` object into an array that contains all of the values\n         * stored inside the `Optional`. In practice, this means the output will have\n         * either 0 or 1 elements.\n         */\n        toArray() {\n            return this.tag ? [this.value] : [];\n        }\n        /**\n         * Turn the `Optional` object into a string for debugging or printing. Not\n         * recommended for production code, but good for debugging. Also note that\n         * these days an `Optional` object can be logged to the console directly, and\n         * its inner value (if it exists) will be visible.\n         */\n        toString() {\n            return this.tag ? `some(${this.value})` : 'none()';\n        }\n    }\n    // Sneaky optimisation: every instance of Optional.none is identical, so just\n    // reuse the same object\n    Optional.singletonNone = new Optional(false);\n\n    const nativeIndexOf = Array.prototype.indexOf;\n    /* eslint-enable */\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const contains = (xs, x) => rawIndexOf(xs, x) > -1;\n    const findUntil = (xs, pred, until) => {\n        for (let i = 0, len = xs.length; i < len; i++) {\n            const x = xs[i];\n            if (pred(x, i)) {\n                return Optional.some(x);\n            }\n            else if (until(x, i)) {\n                break;\n            }\n        }\n        return Optional.none();\n    };\n\n    // There are many variations of Object iteration that are faster than the 'for-in' style:\n    // http://jsperf.com/object-keys-iteration/107\n    //\n    // Use the native keys if it is available (IE9+), otherwise fall back to manually filtering\n    const keys = Object.keys;\n    const each = (obj, f) => {\n        const props = keys(obj);\n        for (let k = 0, len = props.length; k < len; k++) {\n            const i = props[k];\n            const x = obj[i];\n            f(x, i);\n        }\n    };\n    const map = (obj, f) => {\n        return tupleMap(obj, (x, i) => ({\n            k: i,\n            v: f(x, i)\n        }));\n    };\n    const tupleMap = (obj, f) => {\n        const r = {};\n        each(obj, (x, i) => {\n            const tuple = f(x, i);\n            r[tuple.k] = tuple.v;\n        });\n        return r;\n    };\n\n    var global = tinymce.util.Tools.resolve('tinymce.util.Tools');\n\n    const isCustomList = (list) => /\\btox\\-/.test(list.className);\n    const isChildOfBody = (editor, elm) => {\n        return editor.dom.isChildOf(elm, editor.getBody());\n    };\n    const matchNodeNames = (regex) => (node) => isNonNullable(node) && regex.test(node.nodeName);\n    const isListNode = matchNodeNames(/^(OL|UL|DL)$/);\n    const isTableCellNode = matchNodeNames(/^(TH|TD)$/);\n    const inList = (editor, parents, nodeName) => findUntil(parents, (parent) => isListNode(parent) && !isCustomList(parent), isTableCellNode)\n        .exists((list) => list.nodeName === nodeName && isChildOfBody(editor, list));\n    const getSelectedStyleType = (editor) => {\n        const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n        const style = editor.dom.getStyle(listElm, 'listStyleType');\n        return Optional.from(style);\n    };\n    // Lists/core/Util.ts - Duplicated in Lists plugin\n    const isWithinNonEditable = (editor, element) => element !== null && !editor.dom.isEditable(element);\n    const isWithinNonEditableList = (editor, element) => {\n        const parentList = editor.dom.getParent(element, 'ol,ul,dl');\n        return isWithinNonEditable(editor, parentList) || !editor.selection.isEditable();\n    };\n    const setNodeChangeHandler = (editor, nodeChangeHandler) => {\n        const initialNode = editor.selection.getNode();\n        // Set the initial state\n        nodeChangeHandler({\n            parents: editor.dom.getParents(initialNode),\n            element: initialNode\n        });\n        editor.on('NodeChange', nodeChangeHandler);\n        return () => editor.off('NodeChange', nodeChangeHandler);\n    };\n\n    // <ListStyles>\n    const styleValueToText = (styleValue) => {\n        return styleValue.replace(/\\-/g, ' ').replace(/\\b\\w/g, (chr) => {\n            return chr.toUpperCase();\n        });\n    };\n    const normalizeStyleValue = (styleValue) => isNullable(styleValue) || styleValue === 'default' ? '' : styleValue;\n    const makeSetupHandler = (editor, nodeName) => (api) => {\n        const updateButtonState = (editor, parents) => {\n            const element = editor.selection.getStart(true);\n            api.setActive(inList(editor, parents, nodeName));\n            api.setEnabled(!isWithinNonEditableList(editor, element));\n        };\n        const nodeChangeHandler = (e) => updateButtonState(editor, e.parents);\n        return setNodeChangeHandler(editor, nodeChangeHandler);\n    };\n    const addSplitButton = (editor, id, tooltip, cmd, nodeName, styles) => {\n        const listStyleTypeAliases = {\n            'lower-latin': 'lower-alpha',\n            'upper-latin': 'upper-alpha',\n            'lower-alpha': 'lower-latin',\n            'upper-alpha': 'upper-latin'\n        };\n        const stylesContainsAliasMap = map(listStyleTypeAliases, (alias) => contains(styles, alias));\n        editor.ui.registry.addSplitButton(id, {\n            tooltip,\n            icon: nodeName === \"OL\" /* ListType.OrderedList */ ? 'ordered-list' : 'unordered-list',\n            presets: 'listpreview',\n            columns: nodeName === \"OL\" /* ListType.OrderedList */ ? 3 : 4,\n            fetch: (callback) => {\n                const items = global.map(styles, (styleValue) => {\n                    const iconStyle = nodeName === \"OL\" /* ListType.OrderedList */ ? 'num' : 'bull';\n                    const iconName = styleValue === 'decimal' ? 'default' : styleValue;\n                    const itemValue = normalizeStyleValue(styleValue);\n                    const displayText = styleValueToText(styleValue);\n                    return {\n                        type: 'choiceitem',\n                        value: itemValue,\n                        icon: 'list-' + iconStyle + '-' + iconName,\n                        text: displayText\n                    };\n                });\n                callback(items);\n            },\n            onAction: () => editor.execCommand(cmd),\n            onItemAction: (_splitButtonApi, value) => {\n                applyListFormat(editor, nodeName, value);\n            },\n            select: (value) => {\n                const listStyleType = getSelectedStyleType(editor);\n                return listStyleType.exists((listStyle) => value === listStyle || (listStyleTypeAliases[listStyle] === value && !stylesContainsAliasMap[value]));\n            },\n            onSetup: makeSetupHandler(editor, nodeName)\n        });\n    };\n    const addButton = (editor, id, tooltip, cmd, nodeName, styleValue) => {\n        editor.ui.registry.addToggleButton(id, {\n            active: false,\n            tooltip,\n            icon: nodeName === \"OL\" /* ListType.OrderedList */ ? 'ordered-list' : 'unordered-list',\n            onSetup: makeSetupHandler(editor, nodeName),\n            // Need to make sure the button removes rather than applies if a list of the same type is selected\n            onAction: () => editor.queryCommandState(cmd) || styleValue === '' ? editor.execCommand(cmd) : applyListFormat(editor, nodeName, styleValue)\n        });\n    };\n    const addControl = (editor, id, tooltip, cmd, nodeName, styles) => {\n        if (styles.length > 1) {\n            addSplitButton(editor, id, tooltip, cmd, nodeName, styles);\n        }\n        else {\n            addButton(editor, id, tooltip, cmd, nodeName, normalizeStyleValue(styles[0]));\n        }\n    };\n    const register = (editor) => {\n        addControl(editor, 'numlist', 'Numbered list', 'InsertOrderedList', \"OL\" /* ListType.OrderedList */, getNumberStyles(editor));\n        addControl(editor, 'bullist', 'Bullet list', 'InsertUnorderedList', \"UL\" /* ListType.UnorderedList */, getBulletStyles(editor));\n    };\n\n    var Plugin = () => {\n        global$1.add('advlist', (editor) => {\n            if (editor.hasPlugin('lists')) {\n                register$1(editor);\n                register(editor);\n                register$2(editor);\n            }\n            else {\n                // eslint-disable-next-line no-console\n                console.error('Please use the Lists plugin together with the List Styles plugin.');\n            }\n        });\n    };\n\n    Plugin();\n    /** *****\n     * DO NOT EXPORT ANYTHING\n     *\n     * IF YOU DO ROLLUP WILL LEAVE A GLOBAL ON THE PAGE\n     *******/\n\n})();\n", "// Exports the \"advlist\" plugin for usage with module loaders\n// Usage:\n//   CommonJS:\n//     require('tinymce/plugins/advlist')\n//   ES2015:\n//     import 'tinymce/plugins/advlist'\nrequire('./plugin.js');"],
  "mappings": "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",
  "names": ["editor"]
}
