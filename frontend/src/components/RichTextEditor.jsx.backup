import React, { useRef, useEffect, useMemo } from 'react';
import { Editor } from '@tinymce/tinymce-react';
import useTinymceConfig from '../hooks/useTinymceConfig';
import { initLightboxPlugin, lightboxEditorStyles } from '../utils/tinymceLightboxPlugin';

// Import TinyMCE so we can use it locally
import tinymce from 'tinymce/tinymce';

// Import TinyMCE themes and plugins
import 'tinymce/themes/silver';
import 'tinymce/models/dom';

// Import plugins
import 'tinymce/plugins/advlist';
import 'tinymce/plugins/autolink';
import 'tinymce/plugins/lists';
import 'tinymce/plugins/link';
import 'tinymce/plugins/image';
import 'tinymce/plugins/charmap';
import 'tinymce/plugins/preview';
import 'tinymce/plugins/anchor';
import 'tinymce/plugins/searchreplace';
import 'tinymce/plugins/visualblocks';
import 'tinymce/plugins/code';
import 'tinymce/plugins/fullscreen';
import 'tinymce/plugins/insertdatetime';
import 'tinymce/plugins/media';
import 'tinymce/plugins/table';
import 'tinymce/plugins/wordcount';
import 'tinymce/plugins/pagebreak';

// Import TinyMCE icons
import 'tinymce/icons/default';

// Import skin
import 'tinymce/skins/ui/oxide/skin.css';

// Import content CSS
import 'tinymce/skins/content/default/content.css';

const RichTextEditor = ({ 
  value, 
  onChange, 
  height = 500, 
  editorConfig,
  profileId = null,
  contentType = null,
  disabled = false,
  placeholder = ''
}) => {
  const editorRef = useRef(null);
  
  // Fetch configuration based on profile or content type
  const { config, loading, error, isUsingFallback } = useTinymceConfig(profileId, {
    contentType,
    useCache: true
  });

  useEffect(() => {
    // Initialize lightbox plugin when TinyMCE is ready
    // Delay to ensure TinyMCE is fully loaded
    const timer = setTimeout(() => {
      if (typeof tinymce !== 'undefined' && tinymce.PluginManager) {
        initLightboxPlugin(tinymce);
      }
    }, 100);
    
    return () => {
      clearTimeout(timer);
      // Cleanup on unmount
      if (editorRef.current && typeof tinymce !== 'undefined') {
        tinymce.remove(editorRef.current);
      }
    };
  }, []);

  const handleEditorChange = (content, editor) => {
    onChange(content);
  };

  // Default configuration
  const defaultConfig = {
    license_key: 'gpl', // Use GPL license
    height: height,
    menubar: true,
    skin: false, // Disable skin loading since we import it
    content_css: false, // Disable content CSS loading since we import it
    plugins: [
      'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
      'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
      'insertdatetime', 'media', 'table', 'wordcount', 'pagebreak'
    ],
    toolbar: 'undo redo | blocks | ' +
      'bold italic forecolor | alignleft aligncenter ' +
      'alignright alignjustify | bullist numlist outdent indent | ' +
      'link image media | pagebreak | removeformat | code',
    contextmenu: 'link image table setlightbox',
    pagebreak_separator: '<!-- pagebreak -->',
    pagebreak_split_block: true,
    relative_urls: false,
    remove_script_host: false,
    convert_urls: false,
    document_base_url: window.location.origin + '/',
    base_url: '/tinymce',
    suffix: '.min',
    automatic_uploads: true,
    images_reuse_filename: true,
    images_upload_handler: (blobInfo, success, failure) => {
      const formData = new FormData();
      formData.append('image', blobInfo.blob(), blobInfo.filename());

      const token = localStorage.getItem('token');
      
      fetch('/api/upload/image', {
        method: 'POST',
        body: formData,
        headers: {
          'Authorization': token ? `Bearer ${token}` : ''
        }
      })
      .then(response => {
        if (!response.ok) {
          throw new Error('Upload failed');
        }
        return response.json();
      })
      .then(result => {
        if (result.url) {
          success(result.url);
        } else if (result.location) {
          success(result.location);
        } else {
          failure('Upload failed - no URL returned');
        }
      })
      .catch((error) => {
        console.error('Upload error:', error);
        failure('Upload error: ' + error.message);
      });
    },
    // File picker for image dialog
    file_picker_types: 'image',
    file_picker_callback: (callback, value, meta) => {
      if (meta.filetype === 'image') {
        const input = document.createElement('input');
        input.setAttribute('type', 'file');
        input.setAttribute('accept', 'image/*');
        
        input.onchange = function() {
          const file = this.files[0];
          const reader = new FileReader();
          
          reader.onload = function() {
            const id = 'blobid' + (new Date()).getTime();
            const blobCache = tinymce.activeEditor.editorUpload.blobCache;
            const base64 = reader.result.split(',')[1];
            const blobInfo = blobCache.create(id, file, base64);
            blobCache.add(blobInfo);
            
            callback(blobInfo.blobUri(), { title: file.name });
          };
          
          reader.readAsDataURL(file);
        };
        
        input.click();
      }
    },
    content_style: 'body { font-family:Helvetica,Arial,sans-serif; font-size:14px } ' +
      'img { max-width: 100%; height: auto; display: block; margin: 10px 0; } ' +
      (typeof lightboxEditorStyles === 'string' ? lightboxEditorStyles : '') +
      // Style for ALL possible pagebreak implementations
      '.mce-pagebreak, div.mce-pagebreak, img.mce-pagebreak, div[data-mce-pagebreak], hr.mce-pagebreak { ' +
      'display: block !important; clear: both; width: 100% !important; ' +
      'height: 40px !important; margin: 20px 0 !important; padding: 0 !important; ' +
      'border: none !important; background: transparent !important; ' +
      'position: relative !important; overflow: visible !important; ' +
      'background-image: repeating-linear-gradient(90deg, #999 0, #999 10px, transparent 10px, transparent 20px) !important; ' +
      'background-size: 100% 2px !important; background-position: center center !important; ' +
      'background-repeat: no-repeat !important; } ' +
      // Add visible label
      '.mce-pagebreak::before, div.mce-pagebreak::before, img.mce-pagebreak::before, div[data-mce-pagebreak]::before, hr.mce-pagebreak::before { ' +
      'content: "PAGE BREAK" !important; position: absolute !important; ' +
      'left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; ' +
      'background: white !important; padding: 5px 20px !important; ' +
      'color: #666 !important; font-size: 12px !important; font-weight: bold !important; ' +
      'border: 2px solid #999 !important; border-radius: 4px !important; ' +
      'font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif !important; ' +
      'z-index: 1 !important; } ' +
      // Hover effect
      '.mce-pagebreak:hover, div.mce-pagebreak:hover, img.mce-pagebreak:hover, div[data-mce-pagebreak]:hover, hr.mce-pagebreak:hover { ' +
      'background-image: repeating-linear-gradient(90deg, #0066cc 0, #0066cc 10px, transparent 10px, transparent 20px) !important; } ' +
      '.mce-pagebreak:hover::before, div.mce-pagebreak:hover::before, img.mce-pagebreak:hover::before, div[data-mce-pagebreak]:hover::before, hr.mce-pagebreak:hover::before { ' +
      'background: #e3f2fd !important; color: #0066cc !important; border-color: #0066cc !important; }',
    // Visual representation in editor
    visual: true,
    visualblocks_default_state: false,
    // Extended valid elements to include our custom pagebreak
    extended_valid_elements: 'div[class|style|contenteditable|data-mce-resize],p',
    valid_children: '+body[div],+div[div]',
    // Allow our custom styles
    valid_styles: {
      '*': 'display,width,height,margin,position,user-select,background,left,right,top,transform,padding,border,border-radius,color,font-size,font-weight,font-family'
    },
    // Setup function for pagebreak and lightbox handling
    setup: (editor) => {
      // When editor initializes
      editor.on('init', () => {
        // Add lightbox functionality after editor is ready
        if (typeof tinymce !== 'undefined' && tinymce.PluginManager) {
          try {
            // Check if plugin isn't already added
            if (!tinymce.PluginManager.get('lightboximage')) {
              initLightboxPlugin(tinymce);
            }
            // Add lightbox button to toolbar if not present
            if (editor.ui.registry.getAll().buttons.lightboximage) {
              const toolbar = editor.settings.toolbar || '';
              if (!toolbar.includes('lightboximage')) {
                editor.settings.toolbar = toolbar.replace('media', 'media lightboximage');
              }
            }
          } catch (e) {
            console.warn('Could not initialize lightbox plugin:', e);
          }
        }
        
        // Add enhanced styles for the pagebreak plugin
        const style = editor.dom.create('style');
        style.innerHTML = `
          /* Style the TinyMCE pagebreak plugin element */
          .mce-pagebreak {
            display: block !important;
            width: 100% !important;
            height: 5px !important;
            margin: 20px 0 !important;
            background: repeating-linear-gradient(
              90deg,
              #999 0,
              #999 10px,
              transparent 10px,
              transparent 20px
            ) !important;
            border: none !important;
            clear: both !important;
            cursor: default !important;
            page-break-before: always !important;
          }
          
          /* Print styles */
          @media print {
            .mce-pagebreak {
              display: block !important;
              page-break-before: always !important;
              page-break-after: auto !important;
              break-before: page !important;
              height: 0 !important;
              margin: 0 !important;
              border: none !important;
              background: none !important;
            }
          }
        `;
        editor.getDoc().getElementsByTagName('head')[0].appendChild(style);
      });
    }
  };

  // Merge configuration with component-specific settings
  const finalConfig = useMemo(() => {
    // If explicit editorConfig is provided, use it
    if (editorConfig) {
      return editorConfig;
    }

    // If we have a dynamic config from the hook, merge it with defaults
    if (config) {
      return {
        ...defaultConfig,
        ...config,
        height: height,
        placeholder: placeholder,
        // Always ensure these are set for local TinyMCE
        skin: false,
        content_css: false,
        base_url: '/tinymce',
        suffix: '.min',
        // Override image upload handler to ensure it works
        images_upload_handler: defaultConfig.images_upload_handler
      };
    }

    // Fallback to default config
    return defaultConfig;
  }, [config, editorConfig, height, placeholder]);

  if (loading && !editorConfig) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: height + 'px' }}>
        <div style={{ textAlign: 'center' }}>
          <div className="spinner" style={{ 
            width: '40px', 
            height: '40px', 
            border: '4px solid #f3f3f3',
            borderTop: '4px solid #3498db',
            borderRadius: '50%',
            animation: 'spin 1s linear infinite',
            margin: '0 auto 10px'
          }}></div>
          <style dangerouslySetInnerHTML={{ __html: `
            @keyframes spin {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }
          `}} />
          <p>Loading editor configuration...</p>
        </div>
      </div>
    );
  }

  if (error && !isUsingFallback && !editorConfig) {
    return (
      <div style={{ 
        padding: '12px 16px',
        marginBottom: '16px',
        backgroundColor: '#fee',
        border: '1px solid #fcc',
        borderRadius: '4px',
        color: '#c00'
      }}>
        Failed to load editor configuration: {error}
      </div>
    );
  }

  return (
    <>
      {isUsingFallback && !editorConfig && (
        <div style={{ 
          padding: '12px 16px',
          marginBottom: '8px',
          backgroundColor: '#e3f2fd',
          border: '1px solid #90caf9',
          borderRadius: '4px',
          color: '#1565c0'
        }}>
          Using default editor configuration
        </div>
      )}
      <Editor
        tinymceScriptSrc={undefined}
        onInit={(evt, editor) => editorRef.current = editor}
        value={value}
        onEditorChange={handleEditorChange}
        init={finalConfig}
        disabled={disabled}
      />
    </>
  );
};

export default RichTextEditor;